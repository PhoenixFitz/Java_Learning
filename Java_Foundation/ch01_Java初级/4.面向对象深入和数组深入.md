# 面向对象深入和数组深入
## 1.抽象方法和抽象类
### （1）抽象方法
使用**abstract**修饰的方法，**没有方法体，只有声明**。
### （2）抽象类
包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。抽象类的使用要点：
- **有抽象方法的类只能定义成抽象类**。
- 抽象类不能实例化，即**不能用new来实例化抽象类**。
- 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，**只能用来被子类调用**。
- **抽象类只能用来被继承**。
- **抽象方法必须被子类实现**。  
[TestAbstractClass.java](Code/TestAbstractClass.java)
## 2.接口
### （1）接口的作用
接口可以更加规范的对子类进行约束。全面地专业地实现了：规范和具体实现的分离。抽象类还提供某些具体实现，接口不提供任何实现，**接口中所有方法都是抽象方法**。接口和实现类不是父子关系，是实现规则的关系。
### （2）定义和使用接口
```
[访问修饰符]  interface 接口名   [extends  父接口1，父接口2…]  {
常量定义；  
方法定义；
}
```
- 访问修饰符：只能是public或默认。
- 接口名：和类名采用相同命名机制。
- extends：接口可以多继承。
- 常量：接口中的属性**只能是常量**，**总是public static final**修饰，省略也是。
- 方法：接口中的方法**只能是public abstract**，省略也是。  
**实现的要点**：
- 子类通过**implements来实现**接口中的规范。
- 接口不能创建实例，但是可用于声明引用变量类型。
- 一个类实现了接口，必须实现接口中**所有的方法**，并且这些方法**只能是public的**。
- JDK1.8后接口中可包含静态常量、抽象方法、普通的静态方法，不能有普通属性、构造方法、普通方法。  
[TestInterface.java](Code/TestInterface.java)
### （3）接口的多继承
接口完全支持多继承。和类的继承类似，子接口扩展某个父接口，将会获得父接口中所定义的一切。
```
interface A {
    void testa();
}
interface B {
    void testb();
}
/**接口可以多继承：接口C继承接口A和B*/
interface C extends A, B {
    void testc();
}
public class Test implements C {
    public void testc() {
    }
    public void testa() {
    }
    public void testb() {
    }
}
```
## 3.内部类
在Java中内部类主要分为成员内部类(非静态内部类、静态内部类)、匿名内部类、局部内部类。  
成员内部类(可以使用private、default、protected、public任意进行修饰。 类文件：外部类$内部类.class)  
内部类的作用：
- 内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包中的其他类直接访问。
- 内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性。
### （1）非静态内部类
非静态内部类必须寄存在一个外部类对象里，非静态内部类对象单独属于外部类的某个对象；非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员；非静态内部类不能有静态方法、静态属性和静态初始化块；外部类的静态方法、静态代码块不能访问非静态内部类。  
成员变量访问要点：  
- 内部类里方法的局部变量：变量名。
- 内部类属性：this.变量名。
- 外部类属性：外部类名.this.变量名。  
[TestInnerClass](Code/TestInnerClass)
### （2）静态内部类
当一个静态内部类对象存在，并不一定存在对应的外部类对象。因此，静态内部类的实例方法不能直接访问外部类的实例方法； 静态内部类看做外部类的一个静态成员。  
[TestStaticInnerClass.java](Code/TestStaticInnerClass.java)
### （3）匿名内部类 
适合那种只需要使用一次的类。**匿名内部类没有访问修饰符，没有构造方法**。安卓开发常用。语法：
```
new  父类构造器(实参类表) \实现接口 () {
           //匿名内部类类体！
}
```  
[TestAnonymousInnerClass.java](Code/TestAnonymousInnerClass.java)
### （4）局部内部类
它是定义在方法内部的，作用域只限于本方法，称为局部内部类。局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法中被使用，出了该方法就会失效。**局部内部类在实际开发中应用很少**。
[TestLocalInnerClass.java](Code/TestLocalInnerClass.java)
## 4.String类
String类又称作不可变字符序列，String位于java.lang包中，Java程序默认导入java.lang包下的所有类。Java字符串就是Unicode字符序列。
- String类的实例
```
String e = ""  ; // 空字符串
String greeting = " Hello World ";
```
- 字符串连接
```
String s1 = "Hello";
String s2 = "World! ";
String s = s1 + s2; //HelloWorld!
```
- "+"连接符：当"+"运算符两侧的操作数中只要有一个是字符串(String)类型，系统会自动将另一个操作数转换为字符串然后再进行连接。
```
int age = 18;
String str = "age is" + age;  //str赋值为"age is 18"
//这种特性通常被用在输出语句中：
System.out.println("age  is" + age);
```
### （1）String类和常量池
- 全局字符串常量池(String Pool)
- class文件常量池(Class Constant Pool)
- 运行时常量池(Runtime Constant Pool)
```
String str1="Klaus";
String str2="Klaus";
String ste3=new String("Klaus");

System.out.println(str1==str2);  //true
System.out.println(str3==str2); //false
//通常比较字符串的时候，使用equals，它比较的是字符串的内容。
System.out.println(str2.equals(str3)); //true
```
[TestStringEquals.java](Code/TestStringEquals.java)
### （2）String类的常用方法
[API文档下载](http://www.oracle.com/technetwork/java/javase/documentation/jdk8-doc-downloads-2133158.html)解压后，选择api文件夹下的index.html  
![](https://i.postimg.cc/CLn4wDfG/String.png)  
[StringTest1.java](Code/StringTest1.java)  [StringTest2.java](Code/StringTest2.java)



