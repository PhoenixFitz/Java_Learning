# 注释、反射、字节码、类加载机制
## 1.基本概念
### (1)什么是注解
Annotation,并不是程序本身，可以对程序做出解释，可以被其他程序读取。  
Annotation的格式：以“@注释名”在代码中存在，还可以添加参数值。如@SuppressWarnings(value="unchecked")。可以附加在package,class,method,field等上面。

## 2.内置注解
- @Override，只适用于修辞方法，表示一个方法声明打算重写父类中的另一个方法声明
- @Deprecated，可用于修辞方法、属性、类，表示不鼓励使用这样的元素
- @SuppressWarnings，用来抑制编译时的警告信息，该注解需要添加一个参数才能正确使用  
[![image.png](https://i.postimg.cc/13NRCrWj/image.png)](https://postimg.cc/ZW4h0pz8)  

## 3.自定义注解
(1). 使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口
(2). 要点：@interface用来声明一个注解
(3). 格式为：
- public @interface 注解名 {定义体}
- 其中的每一个方法实际上是声明了一个配置参数。
- 方法的名称就是参数的名称
- 返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）
- 可以通过default来声明参数的默认值。
- 如果只有一个参数成员，一般参数名为value  
**注意**：注解元素必须要有值。我们定义注解元素时，经常使用空字符串、0作为默认值。也经常使用负数(比如：-1)表示不存在的含义

## 4.元注解
元注解的作用就是负责注解其他注解。Java定义了4个标准的meta-annotation类型。这些类型和它们所支持的类在java.lang.annotation包中可以找到。@Target，@Retention，@Documented，@Inherited
### (1)@Target
作用：用于描述注解的使用范围，如@Target(value=ElementType.TYPE)  
[![Target.png](https://i.postimg.cc/c4P0n8sM/Target.png)](https://postimg.cc/xcGwr8Nc)
### (2)@Retention
作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期  
[![Retention.png](https://i.postimg.cc/yxJ21vSq/Retention.png)](https://postimg.cc/4HgWwv5w)  
[Demo02.java](Code/Code5/Demo02.java)  [SxtAnnotation01.java](Code/Code5/SxtAnnotation01.java)  [SxtAnnotation02.java](Code/Code5/SxtAnnotation02.java)  
使用注解完成类和表结构的映射关系：[Demo03.java](Code/Code5/Demo03.java)  [SxtField.java](Code/Code5/SxtField.java)  [SxtTable.java](Code/Code5/SxtTable.java)  [SxtStudent.java](Code/Code5/SxtStudent.java)

## 5.反射机制reflection
反射机制指的是可以于**运行时**加载、探知、使用编译期间完全未知的类。程序在运行状态中，可以动态加载一个只有名称的类，对于任意一个已加载的类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；如  
`Class c = Class. forName ("com.klaus.test.User");`  
加载完类之后，在堆内存中，就产生了一个 Class 类型的对象（一个类只有一个 Class 对象），这个对象就包含了完整的类的结构信息。
### Class类介绍
- Class类的对象包含了某个被加载类的结构。一个被加载的类对应一个Class对象
- 当一个class被加载，或当加载器（class loader）的defineClass()被JVM调用，JVM 便自动产生一个Class对象
- Class类是Reflection的根源，针对任何想动态加载、运行的类，唯有先获得相应的Class对象  
### Class类的对象获取
- 运用getClass()
- 运用Class.forName()（最常被使用）
- 运用.class 语法  

[Demo1.java](Code/Code5/Demo1.java)  [User.java](Code/Code5/User.java)
## 6.反射机制的常见作用
- 动态加载类、动态获取类的信息（属性、方法、构造器）
- 动态构造对象
- 动态调用类和对象的任意方法、构造器
- 动态调用和处理属性
- 获取泛型信息
- 处理注解  
[Demo2.java](Code/Code5/Demo2.java)  [Demo3.java](Code/Code5/Demo3.java)

## 7.反射机制性能问题
setAccessible：启用和禁用访问安全检查的开关,值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false 则指示反射的对象应该实施 Java 语言访问检查。并不是为true就能访问为false就不能访问。**禁止安全检查，可以提高反射的运行速度**。[Demo06.java](Code/Code5/Demo06.java)

## 8.反射操作泛型
Java采用**泛型擦除的机制**来引入泛型。Java中的泛型仅仅是给编译器javac使用的，**确保数据的安全性和免去强制类型转换的麻烦**。但是，一旦编译完成，所有的**和泛型有关的类型全部擦除**。  
为了通过**反射操作这些类型**以迎合实际开发的需要，Java就**新增了ParameterizedType，GenericArrayType，TypeVariable 和WildcardType**几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。
- ParameterizedType: 表示一种参数化的类型，比如Collection<String>
- GenericArrayType: 表示一种元素类型是参数化类型或者类型变量的数组类型
- TypeVariable: 是各种类型变量的公共父接口
- WildcardType: 代表一种通配符类型表达式，比如?, ? extends Number, ? super Integer【wildcard是一个单词：就是“通配符”】  
[Demo4.java](Code/Code5/Demo4.java)

## 9.反射操作注解
可以通过反射API:**getAnnotations, getAnnotation**获得相关的注解信息，代码可以参考元注解部分。

## 10.动态编译


