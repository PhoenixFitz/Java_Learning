# 注释、反射、字节码、类加载机制
## 1.基本概念
### (1)什么是注解
Annotation,并不是程序本身，可以对程序做出解释，可以被其他程序读取。  
Annotation的格式：以“@注释名”在代码中存在，还可以添加参数值。如@SuppressWarnings(value="unchecked")。可以附加在package,class,method,field等上面。

## 2.内置注解
- @Override，只适用于修辞方法，表示一个方法声明打算重写父类中的另一个方法声明
- @Deprecated，可用于修辞方法、属性、类，表示不鼓励使用这样的元素
- @SuppressWarnings，用来抑制编译时的警告信息，该注解需要添加一个参数才能正确使用  
[![image.png](https://i.postimg.cc/13NRCrWj/image.png)](https://postimg.cc/ZW4h0pz8)  

## 3.自定义注解
(1). 使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口  
(2). 要点：@interface用来声明一个注解  
(3). 格式为：
- public @interface 注解名 {定义体}
- 其中的每一个方法实际上是声明了一个配置参数。
- 方法的名称就是参数的名称
- 返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）
- 可以通过default来声明参数的默认值。
- 如果只有一个参数成员，一般参数名为value  
**注意**：注解元素必须要有值。我们定义注解元素时，经常使用空字符串、0作为默认值。也经常使用负数(比如：-1)表示不存在的含义

## 4.元注解
元注解的作用就是负责注解其他注解。Java定义了4个标准的meta-annotation类型。这些类型和它们所支持的类在java.lang.annotation包中可以找到。@Target，@Retention，@Documented，@Inherited
### (1)@Target
作用：用于描述注解的使用范围，如@Target(value=ElementType.TYPE)  
[![Target.png](https://i.postimg.cc/c4P0n8sM/Target.png)](https://postimg.cc/xcGwr8Nc)
### (2)@Retention
作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期  
[![Retention.png](https://i.postimg.cc/yxJ21vSq/Retention.png)](https://postimg.cc/4HgWwv5w)  
[Demo02.java](Code/Code5/Demo02.java)  [SxtAnnotation01.java](Code/Code5/SxtAnnotation01.java)  [SxtAnnotation02.java](Code/Code5/SxtAnnotation02.java)  
使用注解完成类和表结构的映射关系：[Demo03.java](Code/Code5/Demo03.java)  [SxtField.java](Code/Code5/SxtField.java)  [SxtTable.java](Code/Code5/SxtTable.java)  [SxtStudent.java](Code/Code5/SxtStudent.java)

## 5.反射机制reflection
反射机制指的是可以于**运行时**加载、探知、使用编译期间完全未知的类。程序在运行状态中，可以动态加载一个只有名称的类，对于任意一个已加载的类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；如  
`Class c = Class. forName ("com.klaus.test.User");`  
加载完类之后，在堆内存中，就产生了一个 Class 类型的对象（一个类只有一个 Class 对象），这个对象就包含了完整的类的结构信息。
### Class类介绍
- Class类的对象包含了某个被加载类的结构。一个被加载的类对应一个Class对象
- 当一个class被加载，或当加载器（class loader）的defineClass()被JVM调用，JVM 便自动产生一个Class对象
- Class类是Reflection的根源，针对任何想动态加载、运行的类，唯有先获得相应的Class对象  
### Class类的对象获取
- 运用getClass()
- 运用Class.forName()（最常被使用）
- 运用.class 语法  

[Demo1.java](Code/Code5/Demo1.java)  [User.java](Code/Code5/User.java)
## 6.反射机制的常见作用
- 动态加载类、动态获取类的信息（属性、方法、构造器）
- 动态构造对象
- 动态调用类和对象的任意方法、构造器
- 动态调用和处理属性
- 获取泛型信息
- 处理注解  
[Demo2.java](Code/Code5/Demo2.java)  [Demo3.java](Code/Code5/Demo3.java)

## 7.反射机制性能问题
setAccessible：启用和禁用访问安全检查的开关,值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false 则指示反射的对象应该实施 Java 语言访问检查。并不是为true就能访问为false就不能访问。**禁止安全检查，可以提高反射的运行速度**。[Demo06.java](Code/Code5/Demo06.java)

## 8.反射操作泛型
Java采用**泛型擦除的机制**来引入泛型。Java中的泛型仅仅是给编译器javac使用的，**确保数据的安全性和免去强制类型转换的麻烦**。但是，一旦编译完成，所有的**和泛型有关的类型全部擦除**。  
为了通过**反射操作这些类型**以迎合实际开发的需要，Java就**新增了ParameterizedType，GenericArrayType，TypeVariable 和WildcardType**几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。
- ParameterizedType: 表示一种参数化的类型，比如Collection<String>
- GenericArrayType: 表示一种元素类型是参数化类型或者类型变量的数组类型
- TypeVariable: 是各种类型变量的公共父接口
- WildcardType: 代表一种通配符类型表达式，比如?, ? extends Number, ? super Integer【wildcard是一个单词：就是“通配符”】  
[Demo4.java](Code/Code5/Demo4.java)

## 9.反射操作注解
可以通过反射API:**getAnnotations, getAnnotation**获得相关的注解信息，代码可以参考元注解部分。

## 10.动态编译
### (1)应用场景
- 可以做一个浏览器端编写java代码，上传服务器编译和运行的在线评测系统
- 服务器动态加载某些类文件进行编译
### (2)动态编译的两种做法
- 通过Runtime调用javac，启动新的进程去操作
- 通过JavaCompiler动态编译

### (3)通过JavaCompiler动态编译
```
public static int compileFile(String sourceFile){
// 动态编译
JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
int result = compiler.run(null, null, null,sourceFile);
System.out.println(result==0?" 编译成功 ":" 编译失败 ");
return result;
}
```
- 第一个参数： 为java编译器提供参数
- 第二个参数： 得到 Java 编译器的输出信息
- 第三个参数： 接收编译器的 错误信息
- 第四个参数： 可变参数（是一个String数组）能传入一个或多个 Java 源文件
- 返回值： 0表示编译成功，非0表示编译失败  
[Demo5.java](Code/Code5/Demo5.java)

## 11.脚本引擎执行JavaScript代码
脚本引擎使得 Java 应用程序可以通过一套固定的接口与各种脚本引擎交互，从而达到在Java平台上调用各种脚本语言的目的。**Java脚本API**是连通Java平台和脚本语言的桥梁。  
Java脚本API为开发者提供了如下功能：
- 获取脚本程序输入，通过脚本引擎运行脚本并返回运行结果，这是**最核心的接口**。
- 通过脚本引擎的运行上下文在脚本和 Java 平台间交换数据。
- 通过 Java 应用程序调用脚本函数。  
[Demo6.java](Code/Code5/Demo6.java)  [a.js](Code/Code5/a.js)

## 12.Java字节码操作
java动态性的两种常见方式：字节码操作、反射。  
运行时操作字节码可以实现以下功能：动态生成新的类，动态改变某个类的结构（添加/删除/修改  新的属性/方法）  
优势：比反射开销小，性能高；JAVAasist性能高于反射，低于ASM  
常见的字节码操作类库：
- BCEL，在实际的JVM指令层次上进行操作
- ASM，是一个轻量级java字节码操作框架，直接涉及到JVM底层的操作和指令
- CGLIB，是一个强大的，高性能，高质量的Code生成类库，基于ASM实现
- Javassist，是一个开源的分析、编辑和创建java字节码的类库。性能较ASM差，跟cglib差不多。它主要由CtClass，CtMethod，以及CtField几个类组成。用以执行和JDK反射API中java.lang.Class,,java.lang.reflect.Method,,java.lang.reflect.Method.Field相同的操作。
### JAVAssist库的API详解
[Demo7.java](Code/Code5/Demo7.java)  [Demo8.java](Code/Code5/Demo8.java)  [Author.java](Code/Code5/Author.java)  [Emp.java](Code/Code5/Emp.java)

## 13.JVM运行和类加载全过程
类加载机制： JVM把class文件加载到内存，并对数据进行校验、解析和初始化，最终形成JVM可以直接使用的Java类型的过程。  
[![image.png](https://i.postimg.cc/dVDhNmnf/image.png)](https://postimg.cc/tsQRY6Kd)  
**1）加载**：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。这个过程需要类加载器参与。  
**2）链接**：将Java类的二进制代码合并到JVM的运行状态之中的过程。
- 验证：确保加载的类信息符合JVM规范，没有安全方面的问题。
- 准备：正式为类变量(static变量)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配
- 解析：虚拟机常量池内的符号引用替换为直接引用的过程  

**3）初始化**
- 初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化
- 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。  
[Demo9.java](Code/Code5/Demo9.java)

## 14.类的引用
### 1)类的主动引用（一定会发生类的初始化）
### 2)类的被动引用（不会发生类的初始化）






