# 设计模式GOF23

## 1.模式分类
- 创建型模式：单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。
- 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
- 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。

## 2.单例模式
### （1）核心作用
保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。  
### （2）常见应用场景：
- Windows的Task Manager（任务管理器）就是很典型的单例模式
- windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。
- 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。
- 网站的计数器，一般也是采用单例模式实现，否则难以同步。
- 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
- 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。
- 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。
- Application 也是单例的典型应用（Servlet编程中会涉及到）
- 在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理
- 在servlet编程中，每个Servlet也是单例
- 在spring MVC框架/struts1框架中，控制器对象也是单例  
### （3）优点
- 由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决
- 单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理
### （4）常见的五种单例模式实现方式：
- 饿汉式（线程安全，调用效率高。 但是，不能延时加载。）
- 懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）
- 双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）
- 静态内部类式(线程安全，调用效率高。 但是，可以延时加载)
- 枚举单例(线程安全，调用效率高，不能延时加载)
#### 1）饿汉式
```
public class SingletonDemo02 {
private static /*final*/ SingletonDemo02 s = new SingletonDemo02();
private SingletonDemo02(){} // 私有化构造器
public static /*synchronized*/ SingletonDemo02 getInstance(){
return s;
 }
}
```  
饿汉式单例模式代码中，static变量会在类装载时初始化，此时也不会涉及多个线程对象访问该对象的问题。虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题。因此，可以省略synchronized关键字。**注意**：如果只是加载本类，而不是要调用getInstance()，甚至永远没有调用，则会造成资源浪费！[SingletonDemo1.java](Code/Code6/singleton/SingletonDemo1.java)
#### 2）懒汉式
```
public class SingletonDemo01 {
private static SingletonDemo01 s;
private SingletonDemo01(){} // 私有化构造器
public static synchronized SingletonDemo01 getInstance(){
if(s==null){
s = new SingletonDemo01();
}
return s;
 }
}
```  
要点：延迟加载，真正用的时候才加载。资源利用率高了。但是，每次调用getInstance()方法都要同步，并发效率较低。[SingletonDemo2.java](Code/Code6/singleton/SingletonDemo2.java)
#### 3）双重检测锁
这个模式将同步内容下方到if内部，提高了执行的效率不必每次获取对象时都进行同步，只有第一次才同步创建了以后就没必要了。  
问题：由于编译器优化原因和JVM底层内部模型原因，偶尔会出问题。不建议使用。[SingletonDemo3.java](Code/Code6/singleton/SingletonDemo3.java)
#### 4）静态内部类实现
- 外部类没有static属性，则不会像饿汉式那样立即加载对象。
- 只有真正调用getInstance(),才会加载静态内部类。加载类时是线程 安全的。 instance是static final类型，保证了内存中只有这样一个实例存在，而且只能被赋值一次，从而保证了线程安全性.
- 兼备了并发高效调用和延迟加载的优势。[SingletonDemo4.java](Code/Code6/singleton/SingletonDemo4.java)
#### 5）使用枚举实现单例模式
- 优点：实现简单，枚举本身就是单例模式。由JVM从根本上提供保障！避免通过反射和反序列化的漏洞！
- 缺点：无延迟加载[SingletonDemo5.java](Code/Code6/singleton/SingletonDemo5.java)   [Client.java](Code/Code6/singleton/Client.java)

### （5）方法的选用
- 单例对象 占用资源少，不需要延时加载：枚举式 好于 饿汉式
- 单例对象 占用资源大，需要延时加载：静态内部类式 好于 懒汉式

### （6）反射和反序列化破解以上（不含枚举式）实现方式
[SingletonDemo6.java](Code/Code6/singleton/SingletonDemo6.java)   [Client2.java](Code/Code6/singleton/Client2.java)
[![image.png](https://i.postimg.cc/65HJBdWK/image.png)](https://postimg.cc/8jrnHffX)

### （7）效率测试
CountDownLatch：同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。
- countDown() 当前线程调此方法，则计数减一(建议放在 finally里执行)
- await()， 调用此方法会一直阻塞当前线程，直到计时器的值为0。[Client3.java](Code/Code6/singleton/Client3.java)

## 3.工厂模式
### （1）分类
工厂模式，实现了创建者和调用者的分离。详细分类：
- 简单工厂模式，用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）
- 工厂方法模式，用来生产同一等级结构中的固定产品。（支持增加任意产品）
- 抽象工厂模式，用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）
### （2）面向对象的七大原则
- 单一职责原则（Single Responsibility Principle）：每一个类应该专注于做一件事情。
- 里氏替换原则（Liskov Substitution Principle）：超类存在的地方，子类是可以替换的。
- 依赖倒置原则（Dependence Inversion Principle）：实现尽量依赖抽象，不依赖具体实现。
- 接口隔离原则（Interface Segregation Principle）：应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。
- 迪米特法则（Law Of Demeter）：又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。
- 开闭原则（Open Close Principle）：面向扩展开放，面向修改关闭。
- 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）：尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。
### （3）核心本质
- 实例化对象，用工厂方法代替new操作。
- 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。
### （4）简单工厂模式
- 简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例。
- 对于增加新产品无能为力！不修改代码的话，是无法扩展的。[SimpleFactory](Code/Code6/factory/simplefactory)
### （5）工厂方法模式
