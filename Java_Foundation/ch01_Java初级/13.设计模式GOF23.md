# 设计模式GOF23

## 1.模式分类
- 创建型模式：单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。**关注对象的创建过程**。
- 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。**关注对象和类的组织**。
- 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。**关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责**。

## 2.单例模式
### （1）核心作用
保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。  
### （2）常见应用场景：
- Windows的Task Manager（任务管理器）就是很典型的单例模式
- windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。
- 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。
- 网站的计数器，一般也是采用单例模式实现，否则难以同步。
- 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
- 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。
- 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。
- Application 也是单例的典型应用（Servlet编程中会涉及到）
- 在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理
- 在servlet编程中，每个Servlet也是单例
- 在spring MVC框架/struts1框架中，控制器对象也是单例  
### （3）优点
- 由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决
- 单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理
### （4）常见的五种单例模式实现方式：
- 饿汉式（线程安全，调用效率高。 但是，不能延时加载。）
- 懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）
- 双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）
- 静态内部类式(线程安全，调用效率高。 但是，可以延时加载)
- 枚举单例(线程安全，调用效率高，不能延时加载)
#### 1）饿汉式
```
public class SingletonDemo02 {
private static /*final*/ SingletonDemo02 s = new SingletonDemo02();
private SingletonDemo02(){} // 私有化构造器
public static /*synchronized*/ SingletonDemo02 getInstance(){
return s;
 }
}
```  
饿汉式单例模式代码中，static变量会在类装载时初始化，此时也不会涉及多个线程对象访问该对象的问题。虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题。因此，可以省略synchronized关键字。**注意**：如果只是加载本类，而不是要调用getInstance()，甚至永远没有调用，则会造成资源浪费！[SingletonDemo1.java](Code/Code6/singleton/SingletonDemo1.java)
#### 2）懒汉式
```
public class SingletonDemo01 {
private static SingletonDemo01 s;
private SingletonDemo01(){} // 私有化构造器
public static synchronized SingletonDemo01 getInstance(){
if(s==null){
s = new SingletonDemo01();
}
return s;
 }
}
```  
要点：延迟加载，真正用的时候才加载。资源利用率高了。但是，每次调用getInstance()方法都要同步，并发效率较低。[SingletonDemo2.java](Code/Code6/singleton/SingletonDemo2.java)
#### 3）双重检测锁
这个模式将同步内容下方到if内部，提高了执行的效率不必每次获取对象时都进行同步，只有第一次才同步创建了以后就没必要了。  
问题：由于编译器优化原因和JVM底层内部模型原因，偶尔会出问题。不建议使用。[SingletonDemo3.java](Code/Code6/singleton/SingletonDemo3.java)
#### 4）静态内部类实现
- 外部类没有static属性，则不会像饿汉式那样立即加载对象。
- 只有真正调用getInstance(),才会加载静态内部类。加载类时是线程 安全的。 instance是static final类型，保证了内存中只有这样一个实例存在，而且只能被赋值一次，从而保证了线程安全性.
- 兼备了并发高效调用和延迟加载的优势。[SingletonDemo4.java](Code/Code6/singleton/SingletonDemo4.java)
#### 5）使用枚举实现单例模式
- 优点：实现简单，枚举本身就是单例模式。由JVM从根本上提供保障！避免通过反射和反序列化的漏洞！
- 缺点：无延迟加载[SingletonDemo5.java](Code/Code6/singleton/SingletonDemo5.java)   [Client.java](Code/Code6/singleton/Client.java)

### （5）方法的选用
- 单例对象 占用资源少，不需要延时加载：枚举式 好于 饿汉式
- 单例对象 占用资源大，需要延时加载：静态内部类式 好于 懒汉式

### （6）反射和反序列化破解以上（不含枚举式）实现方式
[SingletonDemo6.java](Code/Code6/singleton/SingletonDemo6.java)   [Client2.java](Code/Code6/singleton/Client2.java)
[![image.png](https://i.postimg.cc/65HJBdWK/image.png)](https://postimg.cc/8jrnHffX)

### （7）效率测试
CountDownLatch：同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。
- countDown() 当前线程调此方法，则计数减一(建议放在 finally里执行)
- await()， 调用此方法会一直阻塞当前线程，直到计时器的值为0。[Client3.java](Code/Code6/singleton/Client3.java)

## 3.工厂模式
### （1）分类
工厂模式，实现了创建者和调用者的分离。详细分类：
- 简单工厂模式，用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码，但实际用得最多）
- 工厂方法模式，用来生产同一等级结构中的固定产品。（支持增加任意产品）
- 抽象工厂模式，用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）
### （2）面向对象的七大原则
- 单一职责原则（Single Responsibility Principle）：每一个类应该专注于做一件事情。
- 里氏替换原则（Liskov Substitution Principle）：超类存在的地方，子类是可以替换的。
- 依赖倒置原则（Dependence Inversion Principle）：实现尽量依赖抽象，不依赖具体实现。
- 接口隔离原则（Interface Segregation Principle）：应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。
- 迪米特法则（Law Of Demeter）：又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。
- 开闭原则（Open Close Principle）：面向扩展开放，面向修改关闭。
- 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）：尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。
### （3）核心本质
- 实例化对象，用工厂方法代替new操作。
- 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。
### （4）简单工厂模式
- 简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例。
- 对于增加新产品无能为力！不修改代码的话，是无法扩展的。[SimpleFactory](Code/Code6/factory/simplefactory)
### （5）工厂方法模式
工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。[factorymethod](Code/Code6/factory/factorymethod)  
简单工厂模式与工厂方法模式对比：
- 结构复杂度：简单工厂模式要占优。简单工厂模式只需一个工厂类，而工厂方法模式的工厂类随着产品类个数增加而增加，这无疑会使类的个数越来越多，从而增加了结构的复杂程度。
- 代码复杂度：简单工厂模式在结构方面相对简洁，但它在代码方面比工厂方法模式复杂。简单工厂模式的工厂类随着产品类的增加需要增加很多方法（或代码），而工厂方法模式每个具体工厂类只完成单一任务，代码简洁。
- 客户端编程难度：工厂方法模式虽然在工厂类结构中引入了接口从而满足了OCP，但是在客户端编码中需要对工厂类进行实例化。而简单工厂模式的工厂类是个静态类，在客户端无需实例化。
- 管理上的难度：工厂方法模式完全满足OCP，即它有非常良好的扩展性。简单工厂模式同样具备良好的扩展性――扩展的时候仅需要修改少量的代码（修改工
厂类的代码）就可以满足扩展性的要求了。尽管这没有完全满足OCP。从维护性的角度分析下。假如某个具体产品类需要进行一定的修改，很可能需要修改对应的工厂类。当同时需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦（对号入座已经是个问题了）。反而简单工厂没有这些麻烦，当多个产品类需要修改是，简单工厂模式仍然仅仅需要修改唯一的工厂类。  
**小结**：理论建议工厂方法模式。但实际上，一般都用简单工厂模式。
### （6）抽象工厂模式
用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。[abstractfactory](Code/Code6/factory/abstractfactory) 

## 4.建造者模式
### （1）本质
- 分离了对象子组件的单独构造(由Builder来负责)和装配(由Director负责)。从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。
- 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。
### （2）适用场景
StringBuilder类的append方法；SQL中的PreparedStatement；JDOM中，DomBuilder、SAXBuilder等。
[Builder](Code/Code6/builder) 

## 5.原型模式prototype
通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。优势有：效率高(直接克隆，避免了重新执行构造过程步骤) 。克隆类似于new，但是不同于new。new创建新的对象属性采用的是默认值。克隆出的对象的属性值完全和原型对象相同。并且克隆出的新对象改变不会影响原型对象。然后，再修改克隆对象的值。
### （1）原型模式实现
Cloneable接口和clone方法
### （2）浅克隆和深克隆
浅克隆：被复制的对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。  
深克隆：深克隆把引用的变量指向复制过的新对象，而不是原有的被引用的对象。**实现方法**：让已实现Clonable接口的类中的属性也实现Clonable接口。基本数据类型和String能够自动实现深度克隆（值的复制）。另外，也可利用序列化和反序列化技术实现深克隆。[Prototype](Code/Code6/prototype) 

## 6.创建型模式总结
- 单例模式:保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。
- 工厂模式:参考第3点。
- 建造者模式：分离了对象子组件的单独构造(由Builder来负责)和装配(由Director负责)。从而可以构造出复杂的对象。
- 原型模式：通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。

## 7.适配器adapter模式
### （1）什么是适配器模式
将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。
### （2）模式中的角色
- 目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。
- 需要适配的类（Adaptee）：需要适配的类或适配者类。
- 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。  
[Adapter](Code/Code6/adapter)

## 8.代理模式(Proxy pattern)
分为静态代理(静态定义代理类)和动态代理(动态生成代理类)
### （1）核心作用
通过代理，控制对对象的访问。可以详细控制访问某个（某类）对象的方法，在调用这个方法前做前置处理，调用这个方法后做后置处理。（即： AOP(Aspect Oriented Programming面向切面编程)的核心实现机制）。
### （2）核心角色
- 抽象角色：定义代理角色和真实角色的公共对外方法
- 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。关注真正的业务逻辑。
- 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。**将统一的流程控制放到代理角色中处理**。
### （3）动态代理
JDK自带的动态代理：
- java.lang.reflect.Proxy，作用：动态生成代理类和对象
- java.lang.reflect.InvocationHandler(处理器接口)，可以通过invoke方法实现对真实角色的代理访问。每次通过Proxy生成代理类对象对象时都要指定对应的处理器对象。  
```
Star realStar = new RealStar();
StarHandler handler = new StarHandler(realStar);
Star proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new
Class[]{Star.class},handler);
proxy.sing();
```
### （4）动态代理相比于静态代理的优点
抽象角色中(接口)声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。[Proxy](Code/Code6/proxy)
### （5）开发框架中应用场景
- struts2中拦截器的实现
- 数据库连接池关闭处理
- Hibernate中延时加载的实现
- mybatis中实现拦截器插件
- AspectJ的实现
- spring中AOP的实现：日志拦截；声明式事务处理
- web service
- RMI远程方法调用
### （6）面向切面编程AOP介绍
它是可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。它是一种新的方法论，它是对传统OOP编程的一种补充。

## 9.桥接模式（bridge）
### （1）核心要点
处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。
### （2）总结
- 桥接模式可以取代多层继承的方案。 多层继承违背了单一职责原则，复用性较差，类的个数也非常多。桥接模式可以极大的减少子类的个数，从而降低管理和维护的成本。
-桥接模式极大的提高了系统可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有的系统，符合开闭原则。[Bridge](Code/Code6/bridge)
### （3）适应场景
- JDBC驱动程序
- AWT中的Peer架构
- 银行日志管理：格式分类：操作日志、交易日志、异常日志。距离分类：本地记录日志、异地记录日志
- 人力资源系统中的奖金计算模块：奖金分类：个人奖金、团体奖金、激励奖金。部门分类：人事部门、销售部门、研发部门。
- OA系统中的消息处理：业务类型：普通消息、加急消息、特急消息。发送消息方式：系统内消息、手机短信、邮件

## 10.组合模式（composite）
### （1）核心要点
- 抽象构件(Component)角色: 定义了叶子和容器构件的共同点
- 叶子(Leaf)构件角色：无子节点
- 容器(Composite)构件角色：有容器特征，可以包含子节点
### （2）工作流程分析
- 组合模式为处理树形结构提供了完美的解决方案，描述了如何将容器和叶子进行递归组合，使得用户在使用时可以一致性的对待容器和叶子。
- 当容器对象的指定方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员，并调用执行。其中，使用了递归调用的机制对整个结构进行处理。  
[Composite](Code/Code6/composite)
### （3）适用场景
把部分和整体的关系用**树形结构**来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象。
- 操作系统的资源管理器
- GUI中的容器层次图
- XML文件解析
- OA系统中，组织结构的处理
- Junit单元测试框架：底层设计就是典型的组合模式，TestCase(叶子)、TestUnite(容器)、Test接口(抽象)

## 11.装饰模式（decorator）
作用：动态地为一个对象增加新的功能；装饰模式是一种用于**代替继承**的技术，**无需通过继承增加子类就能扩展对象的新功能**。使用对象的关联关系代替继承关系，更加灵活，同时**避免类型体系的快速膨胀**。
### （1）实现细节
- Component抽象构件角色：真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰对象交互。
- ConcreteComponent 具体构件角色(真实对象)：io流中的FileInputStream、FileOutputStream
- Decorator装饰角色：持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调用前后增加新的功能。
- ConcreteDecorator具体装饰角色：负责给构件对象增加新的责任。
### （2）IO流实现细节
- Component抽象构件角色：io流中的InputStream、OutputStream、Reader、Writer
- ConcreteComponent 具体构件角色：io流中的FileInputStream、FileOutputStream
- Decorator装饰角色：持有一个抽象构件的引用：io流中的FilterInputStream、FilterOutputStream
- ConcreteDecorator具体装饰角色：负责给构件对象增加新的责任。Io流中的BufferedOutputStream、BufferedInputStream等
### （3）使用场景
- IO中输入流和输出流的设计
- Swing包中图形界面构件功能
- Servlet API 中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper，HttpServletRequestWrapper类，增强了request对象的功能。
- Struts2中，request，response,session对象的处理
### （4）总结
装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要装饰的具体构建类和具体装饰类可以独立变化，以便增加新的具体构建类和具体装饰类。[Decorator](Code/Code6/decorator)    
**优点**：
- 扩展对象功能，比继承灵活，不会导致类个数急剧增加
- 可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更加强大的对象
- 具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加新的具体构件子类和具体装饰子类。  
**缺点**：
- 产生很多小对象。大量小对象占据内存，一定程度上影响性能。
- 装饰模式易于出错，调试排查比较麻烦。
### （5）装饰模式和桥接模式的区别
两个模式都是为了解决过多子类对象问题。但他们的诱因不一样。桥模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能。

## 12.外观模式（facade）
**迪米特法则(最少知识原则)**：一个软件实体应当尽可能少的与其他实体发生相互作用。
### （1）核心
为子系统提供**统一的入口**。封装子系统的复杂性，便于客户端调用。[Facade](Code/Code6/facade)
### （2）常用场景
使用频率很高。各种技术和框架中，都有外观模式的使用。如：JDBC封装后的，commons提供的DBUtils类，Hibernate提供的工具类、Spring JDBC工具类等
 
## 13.享元模式（FlyWeight）
### （1）核心
享元模式以**共享的方式**高效地支持大量细粒度对象的重用。  
享元对象能做到共享的关键是区分了内部状态和外部状态。
- 内部状态：可以共享，不会随环境变化而改变
- 外部状态：不可以共享，会随环境变化而改变
### （2）实现细节
- FlyweightFactory享元工厂类：创建并管理享元对象，享元池一般设计成键值对
- FlyWeight抽象享元类：通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。
- ConcreteFlyWeight具体享元类：为内部状态提供成员变量进行存储
- UnsharedConcreteFlyWeight非共享享元类：不能被共享的子类可以设计为非共享享元类  
[Flyweight](Code/Code6/flyweight)
### （3）应用场景
内存属于稀缺资源，不要随便浪费。如果有很多个完全相同或相似的对象，可以通过享元模式，节省内存。
- 享元模式由于其共享的特性，可以在任何“池”中操作，
比如：线程池、数据库连接池。
- String类的设计也是享元模式
### （4）优缺点
**优点**：
- 极大减少内存中对象的数量
- 相同或相似对象内存中只存一份，极大的节约资源，提高系统性能
- 外部状态相对独立，不影响内部状态  
**缺点**：
- 模式较复杂，使程序逻辑复杂化
- 为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态使运行时间变长。用时间换取了空间。

## 14.结构型模式总结
**核心作用**：是从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题。  
名称|适用场景
:---:|:---:
代理模式|为真实对象提供一个代理，从而控制对真实对象的访问
适配模式|使原本由于接口不兼容不能一起工作的类可以一起工作
桥接模式|处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。
组合模式|将对象组合成树状结构以表示”部分和整体”层次结构，使得客户可以统一的调用叶子对象和容器对象
装饰模式|动态地给一个对象添加额外的功能，比继承灵活
外观模式|为子系统提供统一的调用接口，使得子系统更加容易使用
享元模式|运用共享技术有效的实现管理大量细粒度对象，节省内存，提高效率  

## 15.责任链模式（chain of responsibility）
将能够处理**同一类请求**的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理，如果不能则传递给链上的下一个对象。
### （1）添加新的处理对象
由于责任链的创建完全在客户端，因此新增新的具体处理者对原有类库没有任何影响，只需添加新的类，然后在客户端调用时添加即可。符合开闭原则。
### （2）实现方式
- 链表方式定义职责链，例子所示[chainOfResp](Code/Code6/chainOfResp)
- 非链表方式实现职责链：通过**集合、数组**生成职责链更加实用！实际上，很多项目中，每个具体的Handler并不是由开发团队定义的，而是项目上线后由外部单位追加的，所以使用链表方式定义COR链就很困难。
### （3）常见场景
- Java中，异常机制就是一种责任链模式。一个try可以对应多个catch，
当第一个catch不匹配类型，则自动跳到第二个catch.
- Javascript语言中，事件的冒泡和捕获机制。Java语言中，事件的处理
采用观察者模式。
- Servlet开发中，过滤器的链式处理
- Struts2中，拦截器的调用也是典型的责任链模式

## 16.迭代器模式iterator
#### （1）结构
- 聚合对象：存储数据
- 迭代器：遍历数据  
[Iterator](Code/Code6/iterator)
### （2）常见场景
JDK内置的迭代器(List/Set)

## 17.中介者模式













