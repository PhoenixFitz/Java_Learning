# 面向对象基础
## 1.面向对象和面向过程
- 都是解决问题的思维方式，都是代码组织的方式
- 解决简单问题可以使用面向过程
- 解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。
## 2.对象和类的概念
- 对象（Objecit，Instance）是具体的事物;类（Class）是对对象的抽象;
- 类可以看成一类对象的模板，对象可以看成该类的一个具体实例。
- 类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。 
- 属性用于定义该类或该类对象包含的数据或者说静态特征。属性作用范围是整个类体。
- 方法用于定义该类或该类实例的行为特征和功能实现，面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。  
[SxtStu.java](Code/SxtStu.java)
## 3.内存分析
ava虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。
### （1）栈
- 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等)
- JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等)
- 栈属于线程私有，不能实现线程间的共享。
- 栈是由系统自动分配，速度快!栈是一个连续的内存空间。
### （2）堆
- 堆用于存储创建好的对象和数组(数组也是对象)
- JVM只有一个堆，被所有线程共享
- 堆是一个不连续的内存空间，分配灵活，速度慢。
### （3）方法区
- 方法区实际也是堆，只是用于存储类、常量相关的信息。
- JVM只有一个方法区，被所有线程共享。
-  用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等)  
![](https://s1.ax1x.com/2018/09/17/iZe2jA.png)
## 4.构造方法（构造器）
- 通过**new**关键字调用
- 构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。
- 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加。
- **构造器的方法名必须和类名一致。**  
[TestConstructor.java](Code/TestConstructor.java)  [User.java](Code/User.java)
## 5.垃圾回收机制
垃圾回收的过程：发现无用的对象；回收无用对象占用的内存空间。  
垃圾回收相关算法：引用计数法（缺点“循环引用的无用对象”无法识别），引用可达法（根搜索算法）。  
通用的分代垃圾回收机制：我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。  
![](https://s1.ax1x.com/2018/09/17/iZJm1x.png)  
垃圾回收过程：  
- 新创建的对象，绝大多数都会存储在Eden中，
- 当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区
- 当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。
- 重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中，
- 当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）  
另外，Major GC 是用于清理老年代区域。
## 6.this关键字
this的本质就是“创建好的对象的地址”，由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象”。  
- 在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。
- 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。
- this不能用于static方法中。  
[TestThis.java](Code/TestThis.java)
## 7.static关键字
- **static修饰的成员变量和方法，从属于类；普通变量和方法从属于对象的。**在类被载入时被显式初始化。
- 对于该类的所有对象来说，static成员变量只有一份，被该类的所有对象共享。
- 一般用“类名.类属性/方法”来调用。  
[User2.java](Code/User2.java)
## 8.参数传值机制
- 基本数据类型参数的传值：传递的是值的副本。 副本改变不会影响原件。
- 引用类型参数的传值：引用类型指的是“对象的地址”，副本和原参数都指向了同一个“地址”，改变“副本指向地址对象的值，也意味着原参数指向对象的值也发生了改变”。  
[User3.java](Code/User3.java)
## 9.包（package）机制
通过package实现对类的管理,关键字package。
- 它通常是**类的第一句非注释性语句**。
- 包名：域名倒着写即可，再加上模块名，便于内部管理类。如com.oracle.test。
- 写项目时都要加包，不要使用默认包。
- com.gao和com.gao.car，这两个包没有包含关系，是两个完全独立的包。只是逻辑上看起来后者是前者的一部分。  

java中的常用包|说明
---|---
java.lang|包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。
java.awt|包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。
java.net|包含执行与网络相关的操作的类。
java.io|包含能提供多种输入/输出功能的类。
java.util|包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。

## 10.导入类import
如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。
> 如import java.sql.Date;  
import java.util.*;//导入该包下所有的类。会降低编译速度，但不会降低运行速度。  
- Java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。
- 如果导入两个同名的类，只能用包名+类名来显示调用相关类：
> 如java.util.Date date  = new  java.util.Date();  
- 静态导入的作用是用于导入指定类的静态属性，这样我们可以直接使用静态属性。
> 如import static java.lang.Math.*;//导入Math类的所有静态属性
import static java.lang.Math.PI;//导入Math类的PI属性
## 11.继承
关键字**extends**，子类是父类的扩展，其使用要点：
- 父类也称作超类、基类、派生类等。
- Java中类只有单继承，接口才有多继承。
- 子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。
- 如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。
- instanceof是二元运算符，**左边是对象，右边是类**；当对象是右面类或子类所创建对象时，返回true；否则，返回false。
> 比如 System.out.println(s instanceof Person);  
[TestExtends.java](Code/TestExtends.java)
## 12.方法的重写Override
子类通过重写父类的方法，可以用自身的行为替换父类的行为。方法的重写是实现多态的必要条件。方法的重写需要符合下面的三个要点：
- “==”： 方法名、形参列表相同。
- “≤”：返回值类型和声明异常类型，子类小于等于父类。
- “≥”： 访问权限，子类大于等于父类。  
[TestOverrode.java](Code/TestOverrode.java)
## 13.Object类
- Object类是所有Java类的根基类，也就意味着所有的Java对象都拥有Object类的属性和方法。如果在类的声明中未使用extends关键字指明其父类，则默认继承Object类。  
- Object类中定义有public String toString()方法，其返回值是 String 类型。[TestObject.java](Code/TestObject.java) Object类中toString方法的源码为：  
```
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```
## 14."=="和equals方法
- “==”代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象。
- Object类中定义有：public boolean equals(Object obj)方法，Object 的 equals 方法默认就是比较两个对象的hashcode，是同一个对象的引用时返回 true 否则返回 false。也可根据自己要求重写equals方法[TestEquals.java](Code/TestEquals.java)
