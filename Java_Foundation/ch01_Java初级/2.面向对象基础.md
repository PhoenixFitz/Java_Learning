# 面向对象基础
## 1.面向对象和面向过程
- 都是解决问题的思维方式，都是代码组织的方式
- 解决简单问题可以使用面向过程
- 解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。
## 2.对象和类的概念
- 对象（Objecit，Instance）是具体的事物;类（Class）是对对象的抽象;
- 类可以看成一类对象的模板，对象可以看成该类的一个具体实例。
- 类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。 
- 属性用于定义该类或该类对象包含的数据或者说静态特征。属性作用范围是整个类体。
- 方法用于定义该类或该类实例的行为特征和功能实现，面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。  
[SxtStu.java](Code/SxtStu.java)
## 3.内存分析
ava虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。
### （1）栈
- 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等)
- JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等)
- 栈属于线程私有，不能实现线程间的共享。
- 栈是由系统自动分配，速度快!栈是一个连续的内存空间。
### （2）堆
- 堆用于存储创建好的对象和数组(数组也是对象)
- JVM只有一个堆，被所有线程共享
- 堆是一个不连续的内存空间，分配灵活，速度慢。
### （3）方法区
- 方法区实际也是堆，只是用于存储类、常量相关的信息。
- JVM只有一个方法区，被所有线程共享。
-  用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等)  
![](https://s1.ax1x.com/2018/09/17/iZe2jA.png)
## 4.构造方法（构造器）
- 通过**new**关键字调用
- 构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。
- 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加。
- **构造器的方法名必须和类名一致。**  
[TestConsructor.java](Code/TestConsructor.java)  [User.java](Code/User.java)
## 5.垃圾回收机制
垃圾回收的过程：发现无用的对象；回收无用对象占用的内存空间。  
垃圾回收相关算法：引用计数法（缺点“循环引用的无用对象”无法识别），引用可达法（根搜索算法）。  
通用的分代垃圾回收机制：我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。  
![](https://s1.ax1x.com/2018/09/17/iZJm1x.png)  
垃圾回收过程：  
- 新创建的对象，绝大多数都会存储在Eden中，
- 当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区
- 当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。
- 重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中，
- 当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）  
另外，Major GC 是用于清理老年代区域。
## 6.this关键字
this的本质就是“创建好的对象的地址”，由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象”。  
- 在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。
- 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。
- this不能用于static方法中。  
[TestThis.java](Code/TestThis.java)
## 7.static关键字
- **static修饰的成员变量和方法，从属于类；普通变量和方法从属于对象的**。在类被载入时被显式初始化。
- 对于该类的所有对象来说，static成员变量只有一份，被该类的所有对象共享。
- 一般用“类名.类属性/方法”来调用。  
[User2.java](Code/User2.java)  

区别|生命周期|调用方式|别名|数据存储位置
---:|:---:|:---:|:---:|:---
成员变量|随着对象的创建而存在随着对象的回收而释放|只能被对象调用|实例变量|数据存储在堆内存的对象中
静态变量|随着类的加载而存在随着类的消失而消失|可以被对象调用，也可以用类名调用（推荐类名调用）|类变量|存储在方法区的静态区
## 8.参数传值机制
- 基本数据类型参数的传值：传递的是值的副本。 副本改变不会影响原件。
- 引用类型参数的传值：引用类型指的是“对象的地址”，副本和原参数都指向了同一个“地址”，改变“副本指向地址对象的值，也意味着原参数指向对象的值也发生了改变”。  
[User3.java](Code/User3.java)
## 9.包（package）机制
通过package实现对类的管理,关键字package。
- 它通常是**类的第一句非注释性语句**。
- 包名：域名倒着写即可，再加上模块名，便于内部管理类。如com.oracle.test。
- 写项目时都要加包，不要使用默认包。
- com.gao和com.gao.car，这两个包没有包含关系，是两个完全独立的包。只是逻辑上看起来后者是前者的一部分。  
- 在同一个包里，不能有重名的类。

java中的常用包|说明
---|---
java.lang|包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。
java.awt|包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。
java.net|包含执行与网络相关的操作的类。
java.io|包含能提供多种输入/输出功能的类。
java.util|包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。

## 10.导入类import
如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。
> 如import java.sql.Date;  
import java.util.*;//导入该包下所有的类。会降低编译速度，但不会降低运行速度。  
- Java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。
- 如果导入两个同名的类，只能用包名+类名来显示调用相关类：
> 如java.util.Date date  = new  java.util.Date();  
- 静态导入的作用是用于导入指定类的静态属性，这样我们可以直接使用静态属性。
> 如import static java.lang.Math.*;//导入Math类的所有静态属性
import static java.lang.Math.PI;//导入Math类的PI属性
## 11.继承
关键字**extends**，子类是父类的扩展，其使用要点：
- 父类也称作超类、基类、派生类等。
- Java中类只有单继承，接口才有多继承。
- 子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。
- 如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。
- instanceof是二元运算符，**左边是对象，右边是类**；当对象是右面类或子类所创建对象时，返回true；否则，返回false。
> 比如 System.out.println(s instanceof Person);  
[TestExtends.java](Code/TestExtends.java)
## 12.方法的重写Override
子类通过重写父类的方法，可以用自身的行为替换父类的行为。方法的重写是实现多态的必要条件。方法的重写需要符合下面的三个要点：
- “==”： 方法名、形参列表相同。
- “≤”：返回值类型和声明异常类型，子类小于等于父类。
- “≥”： 访问权限，子类大于等于父类。  
[TestOverrode.java](Code/TestOverrode.java)
## 13.Object类
- Object类是所有Java类的根基类，也就意味着所有的Java对象都拥有Object类的属性和方法。如果在类的声明中未使用extends关键字指明其父类，则默认继承Object类。  
- Object类中定义有public String toString()方法，其返回值是 String 类型。[TestObject.java](Code/TestObject.java) Object类中toString方法的源码为：  
```
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```
## 14."=="和equals方法
- “==”代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象。
- Object类中定义有：public boolean equals(Object obj)方法，Object 的 equals 方法默认就是比较两个对象的hashcode，是同一个对象的引用时返回 true 否则返回 false。但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。也可根据自己要求重写equals方法[TestEquals.java](Code/TestEquals.java)
## 15.super父类对象引用
- super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。[TestSuper01.java](Code/TestSuper01.java)
- 若是构造方法的第一行代码没有显式的调用super(...)或者this(...);那么Java默认都会调用super(),含义是调用父类的无参数构造方法。这里的super()可以省略。[TestSuper02.java](Code/TestSuper02.java)
- 构造方法的调用顺序：**构造方法第一句总是super(…)来调用父类对应的构造方法**。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。
## 16.封装
### （1）编程中封装的具体优点：
- 提高代码的安全性和复用性
- “高内聚”：封装细节，便于修改内部代码，提高可维护性。
- “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。  

### （2）Java中4种“访问控制符”分别为private、default、protected、public，它们说明了面向对象的封装性。
- private 表示私有，只有自己类能访问
- default表示没有修饰符修饰，只有同一个包的类能访问
- protected表示可以被同一个包的类以及**其他包中的子类访问**
- public表示可以被该项目的所有包中的所有类访问  
[TestEncapsulation.java](Code/kang/test/TestEncapsulation.java)  [TestEncapsulation.java](Code/test_encapsulation/TestEncapsulation.java)  
[Person.java](Code/test_encapsulation/Person.java)  

修饰符|同一个类|同一个包中|子类|所有类
:---:|:---:|:---:|:---:|:---:
private|√|×|×|×
default|√|√|×|×
protected|√|√|√|×
public|√|√|√|√
### （3）封装的使用细节
- 一般使用private访问权限
- 提供相应的get/set方法来访问相关属性，这些方法通常是**public修饰**的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)
- 一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰
[TestEncapsulation3.java](Code/TestEncapsulation3.java)  [TestEncapsulation4.java](Code/TestEncapsulation4.java)
## 17.多态
多态指的是同一个方法调用，由于对象不同可能会有不同的行为。
- 多态是**方法的多态**，不是属性的多态(多态与属性无关)
- 多态的存在要有3个必要条件：**继承，方法重写，父类引用指向子类对象**
- 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了  
[TestPolym.java](Code/TestPolym.java)
## 18.对象的转型（casting）
- 父类引用指向子类对象，称这个过程为向上转型，属于自动类型转换。向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。
- 进行类型的强制转换，称之为向下转型。在向下转型过程中，必须将引用变量转成**真实的子类类型(运行时类型)**否则会出现**类型转换异常ClassCastException**。为了避免出现这种异常，可使用instanceof运算符进行判断。
## 19.final关键字
- 修饰变量：被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值  
> final int MAX_SPEED=120;
- 修饰方法：该方法**不可被子类重写**，但是**可以被重载**  
> public final void study(){}
- 修饰类：修饰的类不能被继承。比如：Math、String等  
> final class A{}
## 20.数组
数组是相同类型数据的有序集合。数组的三个基本特点：
- 长度是确定的。数组一旦被创建，它的大小就是不可以改变的。
- 其元素必须是相同类型，不允许出现混合类型。
- 数组类型可以是任何数据类型，包括基本类型和引用类型。
### （1）数组声明
数组声明的方式有两种（一维数组为例）
```
type[] arr_name;  //推荐使用这种方法
type  arr_name[];
```
**注意**：声明的时候并没有实例化任何对象，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关。声明一个数组的时候并没有数组真正被创建。构造一个数组，必须指定长度。[TestArray01.java](Code/TestArray01.java)
### （2）初始化
- 静态初始化：除了用new关键字来产生数组以外，还可以直接在定义数组的同时就为数组元素分配空间并赋值。
- 动态初始化：数组定义与为数组元素分配空间并赋值的操作分开进行。
- 数组的默认初始化：数组定义与为数组元素分配空间并赋值的操作分开进行。  
[Initialization.md](Code/Initialization.md)
### （3）for-each循环
- for-each增强for循环在遍历数组过程中不能修改数组中某元素的值。
- for-each仅适用于遍历，不涉及有关索引(下标)的操作。  
[TestForeach.java](Code/TestForeach.java)
## 21.重载和重写的区别
\*|前提|特点
:---:|:---:|:---:
重载(overload)|所有的重载函数必须在同一个类中|方法名相同，参数列表不同（个数不同，顺序不同，类型不同），与其他的无关（返回值类型、访问控制符）。
重写(override)|必须要有继承关系|方法名必须相同，参数列表必须相同；子类重写父类的方法的访问权限必须大于等于父类的函数的访问权限；子类的返回值类型要等于或者小于父类的返回值。

